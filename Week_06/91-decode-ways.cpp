class Solution {
public:
    int numDecodings(string s) {
        // 进行匹配的时候，有两种选择，一种是独立解码，一种是结合前一个字符进行解码
        
        // 设 dp[i] 为解码到当前索引可能的解码方法数
        
        // dp[0] = 1 <== 第一个索引只有一位，没有前一位，只能单独解码
        // dp[1] = (s[0,1] <= 26) ? 2 else 1; <== 第二个索引可以在前一种的基础上独立解码，也可以结合前一个字符进行解码，因此要么是 1 要么是 2
        // dp[2] = dp[i] + (s[i-1,i] <= 26) ? dp[i - 1] : 0;

        // 注意：特殊边界字符，0 和 大于2 的数
        // 太坑了...
        // 这里注意必须解码出有效的字符串，如果出现无法解析要终止，返回0
        // 0 不能单独解码，需要解码成 20 or 10
        // 21 ~ 26 才能解码

        int dp[s.size()];

        for (int i = 0; i < s.size(); i++) {
            if (i == 0) {
                dp[0] = (s[0] == '0') ? 0 : 1;
            } else if (i == 1) {
                if ('0' == s[i]) {
                    // 前两位不能单独解码
                    if ('0' < s[i - 1] && s[i - 1] <= '2') {
                        // 更正结果
                        dp[1] = 1; 
                        dp[0] = 0; 
                    } else {
                        // 解码无效
                        return 0;
                    }
                } else if (s[i - 1] == '1' || (s[i - 1] == '2' && '0' < s[i] && s[i] <= '6')) {
                    dp[1] = (dp[0] + 1); // 可以和前一位结合解码 
                } else {
                    // 可以单独解码
                    dp[1] = dp[0]; // 不管能否单独解码都是一种解码数
                }
            } else {
                if ('0' == s[i]) {
                    // 不能单独解码
                    if ('0' < s[i - 1] && s[i - 1] <= '2') {
                        // 结合前一位解码
                        dp[i] = dp[i - 2]; 
                    } else {
                        // 解码无效
                        return 0;
                    }
                } else if (s[i - 1] == '1' || (s[i - 1] == '2' && '0' < s[i] && s[i] <= '6')) {
                    dp[i] = dp[i - 1] + dp[i - 2]; // 可以和前一位结合解码 
                } else {
                    // 可以单独解码
                    dp[i] = dp[i - 1]; // 不管能否单独解码都是一种解码数
                }
            }
        }
        return dp[s.size() - 1];
    }
};
