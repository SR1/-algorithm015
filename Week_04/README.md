# 学习笔记 Week 4

## 深度优先搜索、广度优先搜索的实现和特性

1. 区别于暴力搜索
2. 在树/图/状态集中寻找特定节点
3. 状态集的场景：棋盘的变化、数独的变化
4. 对图进行搜索需要添加 visited 标记已访问过的节点
5. 搜索是对节点进行访问，且只会访问一次
6. 根据访问顺序的差别，分为：深度优先搜索、广度优先搜索、带优先级的搜索(启发式搜索)
7. 深度优先搜索的实现两种: 使用递归的实现、使用手动维护栈 + 循环的方式实现
8. 广度优先搜索的实现一般使用队列 + 循环

## 贪心算法的实现和特性

1. 贪心算法的每一步选择都采取当下状态下最好/最优的选择，希望以此得到全局最好/最优的算法
2. 区别于动态规划:
	- 贪心对每个问题的子问题的解决方案作出选择
	- 贪心算法不能回退
	- 动态规划可以理解为是带最优方案的回溯算法
3. 适用的问题:
	- 最小生成树
	- 哈夫曼编码
	- 希望通过相对高效来取得结果比较接近最优解答案的场景
4. 适用场景的问题特征:
	- 问题可分解成子问题
	- 子问题的最优解可递推到最终问题的最优解(最优子结构)

## 二分查找的实现和特性

1. 二分查找的适用条件:
	- 数据的目标函数具有单调性
	- 存在上下界
	- 可以通过索引访问到数据
2. 代码模板:
	- C++
		```cpp
		int binarySearch(const vector<int>& nums, int target) {
			int left = 0, right = (int) nums.size() - 1;
			while (left <= right) {
				int mid = left + (right - left) / 2;
				if (nums[mid] == target) return mid;
				if (nums[mid] < target) left = mid + 1;
				else right = mid - 1;
			}
			return -1;
		}
		```
	- Java
		```java
		public int binarySearch(int[] array, int target) {
			int left = 0, right = array.length - 1;
			while (left <= right) {
				int mid = left + (right - left) / 2;
				if (array[mid] == target) return mid;
				if (array[mid] < target) left = mid + 1;
				else right = mid - 1;
			}
			return -1;
		}
		```

## 解题回顾

### 本周作业篇

#### 深度/广度优先搜索

##### 单词接龙
https://leetcode-cn.com/problems/word-ladder/

**实现思路:** 

广度优先搜索

**实现难点:**

1. 构建单词的转换关系，即从 word => nextWords 的关系图
2. 当字典很大的情况下，容易超时
	- 单词转换算法的调优(基于字典转换 or 基于每个字符替换查找)
	- 按需生成单词转换表
	- set 和 unordered_set 的区别

**边界场景:**

1. wordList 不包含 endWord 时，提前终止
2. 引入 visited 避免重复选中已访问过的单词

**使用到的数据结构:**

deque: 双端队列
1. push_back 往对尾添加元素
2. empty 队列是否为空
3. size 获取队列的大小
4. front 访问队列的第一个元素
5. pop_front 移除队列的第一个元素

set: 基于红黑树的集合，内部有序
unordered_set: 基于哈希的集合，内部无需
1. insert 插入元素
2. size 获取集合大小
3. find 查找元素是否在集合中，当返回值 == set.end() 时，表示没找到

**进一步优化:**

1. 基于图的双向广度优先搜索
2. [基于Kotlin实现的第一版](https://leetcode-cn.com/submissions/detail/108079748/)性能比C++的版本好，需进行进一步对比

##### 岛屿数量
https://leetcode-cn.com/problems/number-of-islands/

**实现思路:**

深度优先搜索、广度优先搜索
岛屿的每块土地都相连，可通过一块土地，访问下一块土地，迭代访问到岛屿的每块土地

**实现难点:**

1. 需要记录每块访问过的土地，避免重复访问，可通过开辟一个新的表格来记录已经访问过的土地格子
2. 比较巧妙的方式是复用输入的二维网格，将访问过的格子标记为`0(水)`，避免额外的空间消耗

**边界场景:**

1. 避免访问到网格之外
2. 提前判断无效的网格，返回0

**使用到的数据结构:**

数组

**进一步优化:**

1. 使用深度优先搜索实现
2. 使用广度优先搜索实现
3. 了解并使用并查集实现

**潜在的坑:**

1. 使用`auto& element = queue.front(); queue.pop_front(); element.first; element.second;`获取并移除队列的第一个元素，再对元素进行访问。可能会因为超过 `queue` 的 capacity ，queue 内部删除了元素，导致访问元素操作出现异常
2. 广度优先搜索的实现涉及元素的创建，可能会带来额外的开销，导致超时

#### 贪心算法

##### 柠檬水找零
https://leetcode-cn.com/problems/lemonade-change/

**实现思路:** 

贪心算法
因为题目中的货币面值满足小额可以整除大额的特性，因此可以尽可能将最大额的钞票找出去，留下小额的用于应对小额找零

**实现难点:**

1. 需要注意，使用大额面值找零后，需要减去已找的钱数
2. 由于此题的可能的面额有限，找零的 Case 很少，可以简单对各种可能的输入做分支判断处理

**进一步优化:**

提前比较，而不是计算后再比较，可减少几个指令(理论上有优化，实际效果不大)

##### 买卖股票的最佳时机 II
https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/

**实现思路:** 

贪心算法
贪心体现在不错过任何一天的收益，也就是只要知道明天会涨，就今天买入明天卖出

**实现难点:**

老实说，这个贪心的点不够明显。

**潜在的坑:**

可能会跟动态规划混淆

##### 分发饼干
https://leetcode-cn.com/problems/assign-cookies/

**实现思路:**

贪心算法
此贪心的最优选择为: 为孩子分配恰好满足其胃口的最小饼干

##### 模拟行走机器人
https://leetcode-cn.com/problems/walking-robot-simulation/

**实现思路:**

贪心算法
老实讲，这道题和贪心扯一起有点牵强，或者说，贪心就是暴力求解?
贪心可以理解为: 只要没有碰到障碍物，就一直往下走

**实现难点:**

1. 需要能够快速查找是否碰到障碍物不能前进
2. 这种类型的查找可以使用 集合
3. 集合可以使用 `set` / `unordered_set`
4. `set` 支持 `pair<int, int>` 而 `unordered_set` 不支持
5. 可以利用 `long` 替代 `pair<int, int>`，巧妙地支持 `unordered_set`
6. 使用上述方法，要注意使用 `unsigned`
7. 关于前进的方向，使用数组关联索引的方式，将不同方向上的dx、dy预置，后续只需要从数组中直接索引，大大地简化了代码
8. 调整方向时，需要注意负数的情况，可将 -1 变为 +3 再取模，避免负数取模后依然得到负数
9. 需要使用一个变量，随时记录最大的欧式距离的平方


**使用到的数据结构:**

`set`、`unordered_set`

#### 二分查找

##### 搜索二维矩阵
https://leetcode-cn.com/problems/search-a-2d-matrix/

**实现思路:**

二分查找
容易想到的是分别对行、列做二分查找，先二分查找到目标行，再在目标行里二分查找到目标
由于题目是 m x n 的矩阵，有一种简化实现的方式是将搜索区间简化成一维 [0, m x n) 区间

**实现难点:**

1. 如果是分别对行、列二分查找，需要注意避免二分查找的相关变量相互混淆

**边界场景:**

1. 如果是一个空矩阵，或者是一个只有空行的矩阵，需要提前终止

### 本周实战篇

### 本周打卡篇

### 历史回顾篇

## 下一步计划
1. 图的双向广度优先算法
2. 并查集算法
2. 通过题解、提交结果页面参考学习他人的思路和实现