# 学习笔记 Week 8

## 位运算

1. 位运算运算符:
	1. 左移 `<<` 
	2. 右移 `>>`
	3. 按位或 `|`
	4. 按位与 `&`
	5. 按位取反 `~`
	6. 按位异或 `^`
2. 异或高级特点
	1. `X ^ 0 = X`
	2. `X ^ 1s = ~X`
	3. `X ^ ~X = 1s`
	4. `X ^ X = 0`
	5. `c = a ^ b` => `b = a ^ c` => `a = b ^ c`
	6. `a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c`
3. 指定位置的位运算
	1. 将 X 右边第 n 位清零: `x & (~0 << n)`
	2. 获取 X 第 n 位值: `(x >> n) & 1`
	3. 获取 X 第 n 位的幂值: `X & (1 << n)`
	4. 仅将第 n 位置为1: `x | (1 << n)`
	5. 仅将第 n 位置为0: `x & (~(1 << n)`
	6. 将 X 最高位至第 n 位(含)清零: `X & ((1 << n) - 1)`
4. 位运算实战要点
	1. 奇偶判断: `x % 2 == x & 1`
	2. 除2: `x / 2 == x >> 1`
	3. 清零最低位的1: `x = x & (x - 1)`
	4. 得到最低位的1: `x & -x`
	5. `x & ~x == 0`

## 布隆过滤器

1. 和哈希表类似的作用，但布隆过滤器只存储元素是否存在的信息，不存储运算值，所占用的存储空间更少
2. 用一个很长的二进制向量和一系列随机映射函数来实现
3. 布隆过滤器可用于检索一个元素是否存在一个集合中
4. 优点: 空间效率和查询时间效率都远远超过一半算法
5. 缺点: 有一定的误识别率(假阳性)，删除困难
6. 使用案例:
	1. 比特币网络
	2. 分布式系统
	3. Redis 缓存
	4. 垃圾邮件、评论过滤

## LRU Cache 的实现和应用

1. 缓存的两要素: 大小、替换策略
2. 常见的缓存策略有: LRU (Least Recently Used)、LFU (Least Frequently Used)
3. LRU 的实现: 哈希表 + 双向链表
4. LRU 的查询、修改、更新复杂度复杂度均为 O(1)

## 初级排序和高级排序的实现和特性

1. 排序算法分为比较类排序和非比较类排序两种
	1. 比较类排序算法通过比较两个元素来决定元素间的相对次序；复杂度不突破 O(nlogn)；又称: 非线性时间比较类排序
	2. 非比较类排序算法不通过比较两个元素来决定元素间的相对次序；复杂度可突破比较类排序的下限，以线性时间运行；又称线性时间非比较类排序
2. 比较类排序算法
	1. 交换排序
		- 冒泡排序
		- 快速排序
	2. 插入排序
		- 简单插入排序
		- 希尔排序
	3. 选择排序
		- 简单选择排序
		- 堆排序
	4. 归并排序
		- 二路归并排序
		- 多路归并排序
3. 非比较类排序算法
	- 计数排序
	- 桶排序
	- 基数排序
4. 面试重点考察复杂度为 O(nlogn)的算法
	- 快速排序
	- 归并排序
	- 堆排序
5. 初级排序: 复杂度 O(n^2)
	- 选择排序: 每次找最小值，然后放到待排序数组的起始位置
	- 插入排序: 从前到后构建有序序列，对未排序数据，在已排序序列中从后往前扫描，找到相应位置并插入
	- 冒泡排序: 嵌套循环，每次查看相邻元素，如果逆序，则交换两个元素
6. 高级排序: 复杂度 O(nlogn)
	- 快速排序
		1. 取标杆数据 pivot
		2. 将小于 pivot 的元素放在 pivot 左边，大于 pivot 的元素放在 pivot 右边
		3. 然后依次对左右子数据进行快速排序
	- 归并排序
		1. 将长度为 n 的序列分为两个长度为 n / 2 的子序列
		2. 对这两个子序列分别进行归并排序
		3. 合并两个有序子序列
	- 堆排序
		1. 数据依次放入堆中，建立小顶堆
		2. 依次取出数据，并删除
7. 特殊排序
	- 计数排序
		- 要求输入的数据必须是有确定范围的整数
		- 将输入的数据值转化为键存储在额外开辟的数组空间中，然后依次把计数大于1的填充回原数组
	- 桶排序
		- 假设输入数据服从均匀分布
		- 将数据分到优先数量的桶里，每个桶再分别排序(有可能使用别的排序算法，或以递归的方式继续进行桶排序)
	- 基数排序
		1. 按照低位先排序，然后收集
		2. 再按高位排序，然后再收集
		3. 以此类推，直到最高位
		4. 可以看做: 有些属性是有优先级的，先按低优先级排序，再按高优先级排序
		
