# 学习笔记 Week 7

## 前缀树

1. 前缀树，又称字典树、Trie 树、单词查找树
2. 前缀树是多叉树
3. 典型应用于统计和排序大量字符串的场景，经常用于搜索引擎词频统计
4. 有点：最大限度减少不必要的字符比较，查找效率优于哈希表
5. 基本性质
	1. 节点本身不存储完整单词
	2. 从根节点到某一节点，路径上经过的单词链接起来即为该节点对应的字符串
	4. 每个节点的所有子节点路径代表的字符都不相同
6. 前缀树的思想是：空间换时间

### 复习

1. 二叉搜索树的中序遍历结果是升序序列

## 并查集

1. 并查集 Disjoint Set
2. 是一个思维上比较跳跃的数据结构
3. 适用场景：组团、配对的场景
4. 基本操作：
	1. makeSet(size): 建立一个新的并查集，包含 size 个元素
	2. unionSet(x, y): 如果元素 x 和元素 y 所在的集合不相关，则合并，否则则不合并
	3. find(x): 找到元素 x 所在的集合的代表元素，该操作也可用于判断两个元素是否位于同一个集合(同一集合的元素的代表元素相同)
5. 实现：
	1. 初始化: 将每个元素的 parent 指向自身
	2. 查找: 向上查找，找到 parent 指向自身的节点，即为集合的代表元素
	3. 合并: 将其中一个集合的代表元素的 parent 指向另一个集合的代表元素的 parent 即可

## 高级搜索

1. 初级搜索为朴素搜索
2. 对初级搜索进行优化: 减少重复(记忆化搜索)、剪枝(忽略次优选择)
3. 搜索方向: 深度优先搜索、广度优先搜索
4. 对搜索方向进行优化: 双向搜索、启发式搜索

### 启发式搜索

1. 使用`PriorityQueue`替代`Queue`，结合启发式函数进行排序
2. 启发式函数，又称估价函数、优先级定义函数。用于评价哪些节点最有希望是一个要查找的节点
3. 启发式函数是一种告知搜索方向的方法，提供一种明智的方法来猜测哪个相邻节点会导向一个目标

## 高级树、 AVL 树和红黑树

1. 高级树结构产生的目标：保证性能
2. 由于二叉搜索树的查询效率只与树的高度有关，因而保证性能的关键就在于保证树的左右子树节点的平衡
3. 基于上述思路，催生了 AVL 树和红黑树

### AVL 树

1. 两个关键概念：
    1. 平衡因子，一般是左子树的高度减去右子树的高度
    2. 通过四种旋转操作保证树的平衡（左旋、右旋、左右旋、右左旋）
    3. 始终保证任何时候，左右子树的高度差与平衡因子相符
2. 不足：节点需存额外信息，且调整次数频繁

### 红黑树

1. 红黑树是一棵近似平衡二叉树
2. 红黑树确保任何一个节点的左右子树的高度差小于两倍
3. 红黑树满足以下条件：
    1. 每个节点要么是红色，要么是黑色
    2. 跟节点为黑色
    3. 每个叶节点（NIL 节点/空节点）为黑色
    4. 不能有相邻接的两个红色节点
    5. 从任意节点到其每个叶子节点的所有路径都包含相同数目的黑色节点
6. 关键性质：从根节点到叶子节点的最长可能路径不多于最短的可能路径的两倍

### AVL 树和红黑树对比

1. AVL 树提供了比红黑树更快的查找效率（AVL 树比红黑树更加平衡）
2. 红黑树提供了比AVL 树更快的插入/删除操作效率（AVL 树的选择操作比红黑树更多）
3. 红黑树比AVL 树更节省空间（AVL 树每个节点都需要额外存储一个Int的平衡因子，红黑树只需额外一bit存储是否红/黑节点）
4. AVL 树多用于数据库（读操作多的场景）；红黑树多用于实现语言内建的数据结构（map/set）（插入/删除操作多的场景）
    
    
    

### 复习

1. 二叉树
2. 二叉搜索树
3. 完美二叉树
4. 树的遍历方式：前序遍历、中序遍历、后序遍历
5. 树和链表没有本质区别，可以将链表视为树的特化，或者极端情况下，树的形态等价于链表的形态
6. 查询二叉搜索树的效率只与树的高度有关
